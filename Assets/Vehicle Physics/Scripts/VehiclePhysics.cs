using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using Game.Scripts.Network;
using Game.Scripts.Util;

[RequireComponent (typeof(Rigidbody))]
/// <summary>
/// Main vehicle controller that includes Wheels, Steering, Suspensions, Mechanic Configuration, Stability, Lights, Sounds, and Damage.
/// </summary>
public class VehiclePhysics : MonoBehaviour 
{
	#region Variables

	[Header("Behaviour Preset")]
	/// <summary>
    /// How must the vehicle behave?
    /// </summary>
    [Tooltip("How must the vehicle behave?")]	
	public BehaviorType behaviorType = BehaviorType.SportsMuscle;
	public enum BehaviorType{CivilianCars, SuperCars, Jeeps, SportsMuscle, Rovers, Custom}
	public CarProperties carProperties;

	[Header("Wheel Type")]
	public WheelType _wheelTypeChoise = WheelType.RWD;
	public enum WheelType{FWD, RWD, AWD, BIASED}
	[Range(0f, 100f)]public float biasedWheelTorque = 100f;

	private CommonSettings commonSettingsInstance;
	private CommonSettings commonSettings {
		get {
			if (commonSettingsInstance == null) {
				commonSettingsInstance = CommonSettings.Instance;
			}
			return commonSettingsInstance;
		}
	}

	internal Rigidbody rigid;							// Rigidbody.
	internal bool isSleeping = false;				// Used For Disabling Unnecessary Raycasts When RB Is Sleeping.
	
	
	// Wheel Transforms Of The Vehicle.
	[Header("Wheel Transforms")]
	public Transform FrontLeftWheelTransform;
	public Transform FrontRightWheelTransform;
	public Transform RearLeftWheelTransform;
	public Transform RearRightWheelTransform;
	public Transform[] ExtraRearWheelsTransform;
	
	// Wheel Colliders Of The Vehicle.
	[Header("Wheel Colliders")]
	public VehiclePhysicsWheelCollider FrontLeftWheelCollider;
	public VehiclePhysicsWheelCollider FrontRightWheelCollider;
	public VehiclePhysicsWheelCollider RearLeftWheelCollider;
	public VehiclePhysicsWheelCollider RearRightWheelCollider;

	// All Wheel Colliders.
	internal VehiclePhysicsWheelCollider[] allWheelColliders;
	
	// Extra Wheels. In case of if your vehicle has extra wheels.
	
	public VehiclePhysicsWheelCollider[] ExtraRearWheelsCollider;
	public bool applyEngineTorqueToExtraRearWheelColliders = true;	//Applies Engine Torque To Extra Rear Wheels.

	// Steering wheel model.
	[Header("Steering")]
	public Transform SteeringWheel;														// Driver Steering Wheel. In case of if your vehicle has individual steering wheel model in interior.
	private Quaternion orgSteeringWheelRot;											// Original rotation of Steering Wheel.
	public SteeringWheelRotateAround steeringWheelRotateAround;		// Current rotation of Steering Wheel.
	public enum SteeringWheelRotateAround { XAxis, YAxis, ZAxis }		//	Rotation axis of Steering Wheel.
	public float steeringWheelAngleMultiplier = 3f;		
	public float steerAngle = 40f;									// Maximum Steer Angle Of Your Vehicle.
	public float highspeedsteerAngle = 15f;					// Maximum Steer Angle At Highest Speed.
	public float highspeedsteerAngleAtspeed = 100f;		// Highest Speed For Maximum Steer Angle.					// Angle multiplier of Steering Wheel.

	[Header("Center Of Mass")]
	public Transform COM;		// Center of mass.

	[Header("Preferences")]
	// Bools.
	public bool canControl = true;																			// Enables / Disables controlling the vehicle.

	public bool engineRunning = false;															// Enables / Disables auto reversing when player press brake button. Useful for if you are making parking style game.
	public bool automaticGear = true;			// Enables / Disables automatic gear shifting of the vehicle.
	internal bool semiAutomaticGear = false;															// Enables / Disables automatic gear shifting of the vehicle.
	internal bool canGoReverseNow = false;
	public bool useRevLimiter = true;								// Rev Limiter above Maximum Engine RPM.
	public bool useExhaustFlame = true;							// Exhaust blow flame.
	public bool useClutchMarginAtFirstGear = true;			// Smooth clutching at first gear.
	public bool autoGenerateGearCurves = true;		// Each gear has it's own torque curve.
	public bool autoGenerateTargetSpeedsForChangingGear = true;		// Target speeds for shifting between gears.
	 
	// Configurations.
					// Each Gear Ratio Curves Generated By Editor Script.

	[Header("Engine")]	
	public float engineTorque = 2000f;							// Default Engine Torque.
	public float brakeTorque = 2000f;							// Maximum Brake Torque.,
	public float minEngineRPM = 1000f;							// Minimum Engine RPM.
	public float maxEngineRPM = 7000f;							// Maximum Engine RPM.
	[Range(.75f, 2f)]public float engineInertia = 1f;		// Inertia of the engine.
	public float maxspeed = 220f;		// Maximum speed.

	[Header("Antiroll")]	
	public float antiRollFrontHorizontal = 5000f;			// Anti Roll Horizontal Force For Preventing Flip Overs And Stability.
	public float antiRollRearHorizontal = 5000f;				// Anti Roll Horizontal Force For Preventing Flip Overs And Stability.
	public float antiRollVertical = 0f;								// Anti Roll Vertical Force For Preventing Flip Overs And Stability. I know it doesn't exist, but it can improve gameplay if you have height COM vehicles like monster trucks.

	// Downforce.
	public float downForce = 25f;		// Applies downforce related with vehicle speed.

	[HideInInspector] public float speed;						// Vehicle speed.
	[HideInInspector] public float orgMaxSpeed;			// Original maximum speed.
	

	private float resetTime = 0f;					// Used for resetting the vehicle if upside down.
	private float orgSteerAngle = 0f;			// Original steer angle.

	[Header("Fuel")]
	public bool useFuelConsumption = false;		// Enable / Disable Fuel Consumption.
	public float fuelTankCapacity = 62f;			// Fuel Tank Capacity.
	public float fuelTank = 62f;							// Fuel Amount.
	public float fuelConsumptionRate = .1f;			// Fuel Consumption Rate.

	// Engine heat.
	[Header("Engine Heat")]
	public bool useEngineHeat = false;							// Enable / Disable engine heat.
	public float engineHeat = 15f;									// Engine heat.
	public float engineCoolingWaterThreshold = 60f;		// Engine coolign water engage point.
	public float engineHeatRate = 1f;								// Engine heat multiplier.
	public float engineCoolRate = 1f;								// Engine cool multiplier.

	// Gears.
	[Header("Transmission")]
	public int currentGear = 0;		// Current Gear Of The Vehicle.
	public int totalGears = 6;			// Total Gears Of The Vehicle.
	[Range(0f, .5f)]public float gearShiftingDelay = .35f;
	[Range(.5f, .95f)]public float gearShiftingThreshold = .85f;
	[Range(.1f, .9f)]public float clutchInertia = .25f;
	private float orgGearShiftingThreshold;		// Original Gear Shifting Threshold.
	[HideInInspector] public bool changingGear = false;		// Changing Gear Currently.
	[HideInInspector] public bool NGear = false;		// N Gear.
	[HideInInspector] public int direction = 1;		// Reverse Gear Currently.
	[HideInInspector] public float launched = 0f;

	
	
	// How many source we will use for simulating engine sounds?. Usually, all modern driving games have around 6 audio sources per vehicle.
	// Low RPM, Medium RPM, and High RPM. And their off versions.

	[Header("Audio System")]
	public AudioType audioType;
	public enum AudioType{OneSource, TwoSource, ThreeSource, Off}

	// If you don't have off versions, generate them.
	public bool autoCreateEngineOffSounds = true;

	// AudioSources and AudioClips.
	private AudioSource engineStartSound;
	public AudioClip engineStartClip;
	internal AudioSource engineSoundHigh;
	public AudioClip engineClipHigh;
	private AudioSource engineSoundMed;
	public AudioClip engineClipMed;
	private AudioSource engineSoundLow;
	public AudioClip engineClipLow;
	private AudioSource engineSoundIdle;
	public AudioClip engineClipIdle;
	private AudioSource gearShiftingSound;

	internal AudioSource engineSoundHighOff;
	public AudioClip engineClipHighOff;
	internal AudioSource engineSoundMedOff;
	public AudioClip engineClipMedOff;
	internal AudioSource engineSoundLowOff;
	public AudioClip engineClipLowOff;

	// Shared AudioSources and AudioClips.
	private AudioClip[] gearShiftingClips{get{return commonSettings.gearShiftingClips;}}
	private AudioSource crashSound;
	private AudioClip[] crashClips{get{return commonSettings.crashClips;}}
	private AudioSource reversingSound;
	private AudioClip reversingClip{get{return commonSettings.reversingClip;}}
	private AudioSource windSound;
	private AudioClip windClip{get{return commonSettings.windClip;}}
	private AudioSource brakeSound;
	private AudioClip brakeClip{get{return commonSettings.brakeClip;}}
	private AudioSource NOSSound;
	private AudioClip NOSClip{get{return commonSettings.NOSClip;}}
	private AudioSource turboSound;
	private AudioClip turboClip{get{return commonSettings.turboClip;}}
	private AudioSource blowSound;
	private AudioClip blowClip{get{return commonSettings.turboClip;}}

	// Min / Max sound pitches and volumes.
	[Range(0f, 1f)]public float minEngineSoundPitch = .75f;
	[Range(1f, 2f)]public float maxEngineSoundPitch = 1.75f;
	[Range(0f, 1f)]public float minEngineSoundVolume = .05f;
	[Range(0f, 1f)]public float maxEngineSoundVolume = .85f;

	// Main Gameobjects for keep the Hierarchy clean and organized.
	private GameObject allContactParticles;
	
	[Header("Inputs")]
	public float gasInput = 0f;
	public float brakeInput = 0f;
	public float steerInput = 0f;
	public float clutchInput = 0f;
	public float handbrakeInput = 0f;
	public float boostInput = 1f;
	public bool cutGas = false;
	public float idleInput = 0f;
	public float fuelInput = 0f;

	//public bool permanentGas = false;

	#region Processed Inputs
	// Processed Inputs. DO NOT FEED THESE VALUES on your own script. Feed only above inputs.
	internal float _gasInput{get{

			if(_fuelInput <= 0f)
				return 0f;

			if(!automaticGear || semiAutomaticGear){
				if(!changingGear && !cutGas)
					return Mathf.Clamp01(gasInput);
				else
					return 0f;
			}else{
				if(!changingGear && !cutGas)
					return (direction == 1 ? Mathf.Clamp01(gasInput) : Mathf.Clamp01(brakeInput));
				else
					return 0f;
			}
				
		}set{gasInput = value;}}

	internal float _brakeInput{get{

			if(!automaticGear || semiAutomaticGear){
				return Mathf.Clamp01(brakeInput);
			}else{
				if(!cutGas)
					return (direction == 1 ? Mathf.Clamp01(brakeInput) : Mathf.Clamp01(gasInput));
				else
					return 0f;
			}
				
		}set{brakeInput = value;}}

	internal float _boostInput{get{
			
			if(useNOS && NoS > 5 && _gasInput >= .5f){
				return boostInput;
			}else{
				return 1f;
			}

		}set{boostInput = value;}}

	internal float _steerInput{get{

			return steerInput + _counterSteerInput;

		}}

	internal float _counterSteerInput{get{

			if (applyCounterSteering)
				return (driftAngle * counterSteeringFactor);
			else
				return 0f;

		}}

	internal float _fuelInput{get{

			if(fuelTank > 0){
				return fuelInput;
			}else{
				if(engineRunning)
					KillEngine ();
				return 0f;
			}

		}set{fuelInput = value;}}

	#endregion

	internal float rawEngineRPM = 0f;	// Actual engine RPM.
	internal float engineRPM = 0f;			// Smoothed engine RPM.

	[Header("Chassis")]
	
	public GameObject chassis;						// Script will simulate chassis movement based on vehicle rigidbody velocity.
	public float chassisVerticalLean = 4f;		// Chassis vertical lean sensitivity.
	public float chassisHorizontalLean = 4f;	// Chassis horizontal lean sensitivity.
	
	// Lights.
	[HideInInspector] public bool lowBeamHeadLightsOn = false;	// Low beam head lights.
	[HideInInspector] public bool highBeamHeadLightsOn = false;	// High beam head lights.

	// For Indicators.
	public IndicatorsOn indicatorsOn;		// Indicator system.
	public enum IndicatorsOn{Off, Right, Left, All}
	public float indicatorTimer = 0f;			// Used timer for indicator on / off sequence.

	class meshVerts
    {
        public Vector3[] verts;//Current mesh vertices
        public Vector3[] initialVerts;//Original mesh vertices
    }

	// Damage.
	[Header("Damage System")]
	public float health = 100;
	public bool useDamage = true;	
	public bool hasPivotIssues = false;												// Use Damage.

    [Range(0, 1)]
    public float strength;
    public float damageFactor = 1;
    public float maxCollisionMagnitude = 100;

    [Tooltip("Maximum collision points to use when deforming, has large effect on performance")]
    public int maxCollisionPoints = 2;

    [Tooltip("Collisions underneath this local y-position will be ignored")]
    public float collisionIgnoreHeight;

    [Tooltip("If true, grounded wheels will not be damaged, but can still be displaced")]
    public bool ignoreGroundedWheels;

    [Tooltip("Minimum time in seconds between collisions")]
    public float collisionTimeGap = 0.1f;
    float hitTime;

    [Tooltip("Whether the edges of adjacent deforming parts should match")]
    public bool seamlessDeform;

    [Tooltip("Add some perlin noise to deformation")]
    public bool usePerlinNoise = true;

    [Tooltip("Recalculate normals of deformed meshes")]
    public bool calculateNormals = true;

    [Tooltip("Meshes that are deformed")]
    public MeshFilter[] deformMeshes;
    bool[] damagedMeshes;
    Mesh[] tempMeshes;
    meshVerts[] meshVertices;

    [Tooltip("Parts that are displaced")]
    public Transform[] displaceParts;
    //Vector3[] initialPartPositions;

    ContactPoint nullContact = new ContactPoint();
	
	public GameObject contactSparkle{get{return commonSettings.contactParticles;}}		// Contact Particles for collisions. It must be Particle System.
	public int maximumContactSparkle = 5;																	//	Contact Particles will be ready to use for collisions in pool. 
	private List<ParticleSystem> contactSparkeList = new List<ParticleSystem>();			// Array for Contact Particles.

	private ParticleSystem engineSmoke{get{return commonSettings.engineSmoke.GetComponent<ParticleSystem>();}}
	private GameObject smokeObj;
	public Transform smokePosition;
	private float initialSmokeEmission;

	// Used for Angular and Linear Steering Helper.
	private Vector3 localVector;
	private Quaternion rot = Quaternion.identity;
	private float oldRotation;
	[HideInInspector] public Transform velocityDirection;
	[HideInInspector] public Transform steeringDirection;
	public float velocityAngle;
	private float angle;
	private float angularVelo;

	[Header("Driving Assistances")]
	public bool ABS = true;
	[Range(.05f, .5f)]public float ABSThreshold = .35f;
	public bool TCS = true;
	[Range(.05f, .5f)]public float TCSThreshold = .5f;
	[Range(.05f, 1f)]public float TCSStrength = 1f;
	public bool ESP = true;
	[Range(.05f, .5f)]public float ESPThreshold = .25f;
	[Range(.05f, 1f)]public float ESPStrength = .5f;
	public bool steeringHelper = true;
	public bool applyCounterSteering = true;							// Applies counter steering when vehicle is drifting. It helps to keep the control fine of the vehicle.
	[Range(0f, 1f)] public float steerHelperLinearVelStrength = .1f;
	[Range(0f, 1f)] public float steerHelperAngularVelStrength = .1f;
	public bool tractionHelper = true;
	
	[Range(0f, 1f)] public float tractionHelperStrength = .1f;

	// Is Driving Assistance is in action now?
	[HideInInspector] public bool ABSAct = false;
	[HideInInspector] public bool TCSAct = false;
	[HideInInspector] public bool ESPAct = false;

	// ESP Bools.
	[HideInInspector] public bool underSteering = false;
	[HideInInspector] public bool overSteering = false;

	// Drift Variables.
	internal bool driftingNow = false;										// Currently drifting?
	internal float driftAngle = 0f;											// If we do, what's the drift angle?
	
	[Range(0f, 1f)]public float counterSteeringFactor = 1f;	// Counter steering multiplier.

	// Used For ESP.
	[HideInInspector] public float frontSlip = 0f;
	[HideInInspector] public float rearSlip = 0f;

	[Header("Turbo and NOS")]
	
	public bool useNOS = false;
	public bool useTurbo = false;
	public float turboBoost = 0f;
	public float NoS = 100f;
	private float NoSConsumption = 25f;
	private float NoSRegenerateTime = 10f;


	[Header("Generated")]
	public AnimationCurve[] engineTorqueCurve;
	public float[] targetSpeedForGear;							// Target Speed For Changing Gear.
	public float[] maxSpeedForGear;	
	

								// Maximum Speed For Current Gear.
    public GameNetworkPlayer Player { protected get; set; }
	private bool permanentGas = false;
	#endregion

    #region Unity Methods
	void Awake (){

		#if UNITY_EDITOR
		if(!carProperties)
		Debug.LogError("Assign Car Properties");
		#endif

		// Getting Rigidbody and settings.
		rigid = GetComponent<Rigidbody>();
		rigid.maxAngularVelocity = commonSettings.maxAngularVelocity;

		// You can configurate wheels for best behavior, but Unity doesn't have docs about it.
		allWheelColliders = GetComponentsInChildren<VehiclePhysicsWheelCollider>();
//		GetComponentInChildren<WheelCollider>().ConfigureVehicleSubsteps(10f, 1, 1);

		FrontLeftWheelCollider.wheelModel = FrontLeftWheelTransform;
		FrontRightWheelCollider.wheelModel = FrontRightWheelTransform;
		RearLeftWheelCollider.wheelModel = RearLeftWheelTransform;
		RearRightWheelCollider.wheelModel = RearRightWheelTransform;

		for (int i = 0; i < ExtraRearWheelsCollider.Length; i++) {
			ExtraRearWheelsCollider[i].wheelModel = ExtraRearWheelsTransform[i];
		}

		// Default Steer Angle. Using it for lerping current steer angle between default steer angle and high speed steer angle.
		orgSteerAngle = steerAngle;

		// Collecting all contact particles in same gameobject.
		allContactParticles = new GameObject("All Contact Particles");
		allContactParticles.transform.SetParent(transform, false);

		// Creating and initializing all audio sources for this vehicle.
		SoundsInitialize();

		// Should we use the damage?
		if(useDamage)
			DamageInit();

		// Proper settings for selected behavior type.
		switch(behaviorType){

		case BehaviorType.Jeeps:
			steeringHelper = true;
			tractionHelper = true;
			ABS = false;
			ESP = false;
			TCS = false;
			steerHelperLinearVelStrength = Mathf.Clamp(steerHelperLinearVelStrength, .5f, 1f);
			steerHelperAngularVelStrength = Mathf.Clamp(steerHelperAngularVelStrength, 1f, 1f);
			tractionHelperStrength = Mathf.Clamp(tractionHelperStrength, .25f, 1f);
			antiRollFrontHorizontal = Mathf.Clamp(antiRollFrontHorizontal, 10000f, Mathf.Infinity);
			antiRollRearHorizontal = Mathf.Clamp(antiRollRearHorizontal, 10000f, Mathf.Infinity);
			gearShiftingDelay = Mathf.Clamp(gearShiftingDelay, 0f, .1f);
			break;

		case BehaviorType.SportsMuscle:
			steeringHelper = false;
			tractionHelper = true;
			ABS = false;
			ESP = false;
			TCS = false;
			highspeedsteerAngle = Mathf.Clamp(highspeedsteerAngle, 40f, 50f);
			highspeedsteerAngleAtspeed = Mathf.Clamp(highspeedsteerAngleAtspeed, 100f, maxspeed);
			tractionHelperStrength = Mathf.Clamp(tractionHelperStrength, .5f, 1f);
			engineTorque = Mathf.Clamp(engineTorque, 2000f, Mathf.Infinity);
			antiRollFrontHorizontal = Mathf.Clamp(antiRollFrontHorizontal, 2500f, Mathf.Infinity);
			antiRollRearHorizontal = Mathf.Clamp(antiRollRearHorizontal, 2500f, Mathf.Infinity);
			gearShiftingDelay = Mathf.Clamp(gearShiftingDelay, 0f, .15f);
			break;

		case BehaviorType.Rovers:
			steeringHelper = true;
			tractionHelper = true;
			ABS = false;
			ESP = false;
			TCS = false;
			steerHelperLinearVelStrength = Mathf.Clamp(steerHelperLinearVelStrength, .5f, 1f);
			steerHelperAngularVelStrength = Mathf.Clamp(steerHelperAngularVelStrength, 1f, 1f);
			highspeedsteerAngle = Mathf.Clamp(highspeedsteerAngle, 30f, 50f);
			highspeedsteerAngleAtspeed = Mathf.Clamp(highspeedsteerAngleAtspeed, 100f, maxspeed);
			antiRollFrontHorizontal = Mathf.Clamp(antiRollFrontHorizontal, 20000f, Mathf.Infinity);
			antiRollRearHorizontal = Mathf.Clamp(antiRollRearHorizontal, 20000f, Mathf.Infinity);
			gearShiftingDelay = Mathf.Clamp(gearShiftingDelay, 0f, .1f);
			break;

		case BehaviorType.SuperCars:
			steeringHelper = true;
			tractionHelper = true;
			steerHelperLinearVelStrength = Mathf.Clamp(steerHelperLinearVelStrength, .25f, 1f);
			steerHelperAngularVelStrength = Mathf.Clamp(steerHelperAngularVelStrength, .25f, 1f);
			tractionHelperStrength = Mathf.Clamp(tractionHelperStrength, .25f, 1f);
			antiRollFrontHorizontal = Mathf.Clamp(antiRollFrontHorizontal, 10000f, Mathf.Infinity);
			antiRollRearHorizontal = Mathf.Clamp(antiRollRearHorizontal, 10000f, Mathf.Infinity);
			break;

		case BehaviorType.CivilianCars:
			antiRollFrontHorizontal = Mathf.Clamp(antiRollFrontHorizontal, 1000f, Mathf.Infinity);
			antiRollRearHorizontal = Mathf.Clamp(antiRollRearHorizontal, 1000f, Mathf.Infinity);
			break;

		}

		//KillEngine();
		smokeObj = (GameObject)Instantiate(engineSmoke.gameObject, smokePosition.position, Quaternion.identity, smokePosition);
		smokeObj.transform.parent = smokePosition;	
		initialSmokeEmission = smokeObj.GetComponent<ParticleSystem>().emission.rateOverTime.constantMax;


	}

	void OnEnable(){

		currentGear = 0;
		changingGear = false;
		isSleeping = false;

		//StartEngine();

	}

	void Update (){
		
		if(canControl){
			
				Inputs();
			
		}else {
			
			_gasInput = 0f;
			brakeInput = 0f;
			boostInput = 1f;
			handbrakeInput = 1f;

		}
			
		Sounds();
		ResetCar();

		OtherVisuals ();
		Smoke();

		indicatorTimer += Time.deltaTime;

		if (_gasInput >= .1f)
			launched += _gasInput * Time.deltaTime;
		else
			launched -= Time.deltaTime;
		
		launched = Mathf.Clamp01 (launched);

		if(health < 0)
		{
			health = 0;
		}
		
	}

	void FixedUpdate (){

		if(rigid.velocity.magnitude < .01f && Mathf.Abs(_steerInput) < .01f && Mathf.Abs(_gasInput) < .01f && Mathf.Abs(rigid.angularVelocity.magnitude) < .01f)
			isSleeping = true;
		else
			isSleeping = false;

		//Decrease timer for collisionTimeGap
        hitTime = Mathf.Max(0, hitTime - Time.fixedDeltaTime);
        //Make sure damageFactor is not negative
        damageFactor = Mathf.Max(0, damageFactor);

		Engine();
		EngineSounds ();

		if (canControl) {
			
			GearBox ();
			Clutch ();

		}

		AntiRollBars();
		DriftVariables();
		RevLimiter();
		Turbo();
		NOS();

		if(useFuelConsumption)
			Fuel();

		if (useEngineHeat)
			EngineHeat ();

		if(steeringHelper)
			SteerHelper();
		
		if(tractionHelper)
			TractionHelper();

		if(ESP)
			ESPCheck(FrontLeftWheelCollider.wheelCollider.steerAngle);

		if(behaviorType == BehaviorType.SportsMuscle){
			
			if (RearLeftWheelCollider.wheelCollider.isGrounded)
				rigid.AddRelativeTorque (Vector3.up * (((steerInput * _gasInput) * direction)) / 1f, ForceMode.Acceleration);
			 
		}
			
		rigid.centerOfMass = transform.InverseTransformPoint(COM.transform.position);

	}

	void OnCollisionEnter (Collision col)
	{
		if (col.contacts.Length < 1)
			return;

		RemoveArrayNullElements();

		if(useDamage)
		{
			if (hitTime == 0 && col.relativeVelocity.sqrMagnitude * damageFactor > 1 && strength < 1)
            {
                Vector3 normalizedVel = col.relativeVelocity.normalized;
                int colsChecked = 0;
                //bool soundPlayed = false;
                //bool sparkPlayed = false;
                hitTime = collisionTimeGap;

                foreach (ContactPoint curCol in col.contacts)
                {
                    if (transform.InverseTransformPoint(curCol.point).y > collisionIgnoreHeight && (1 << col.gameObject.layer) != 0)
                    {
                        colsChecked++;

						CollisionParticles (col.contacts [0].point);
	
				        if(crashClips.Length > 0)
					    {

					        if (col.contacts[0].thisCollider.gameObject.transform != transform.parent)
					        {

						        crashSound = CreateAudioSource.NewAudioSource(gameObject, "Crash Sound AudioSource", 5, 20, commonSettings.maxCrashSoundVolume, crashClips[UnityEngine.Random.Range(0, crashClips.Length)], false, true, true);

						        if(!crashSound.isPlaying)
							       crashSound.Play();

					        }
						}
					}
                    

                    

                    DamageApplication(curCol.point, col.relativeVelocity, maxCollisionMagnitude, curCol.normal, curCol, true, col.transform.FindComponentIncludingParents<VehiclePhysics>());
                    //Stop checking collision points when limit reached
                    if (colsChecked >= maxCollisionPoints)
                    {
                        break;
                    }
                }

                FinalizeDamage();
            }

		}

	}

	#endregion

	#region Inputs, SteeringWheel
	void Inputs(){
			
			gasInput = Input.GetAxis(commonSettings.verticalInput);
			brakeInput = Mathf.Clamp01(-Input.GetAxis(commonSettings.verticalInput));
			handbrakeInput = Input.GetKey(commonSettings.handbrakeKB) ? 1f : 0f;
			steerInput = Input.GetAxis(commonSettings.horizontalInput);
			boostInput = Input.GetKey(commonSettings.boostKB) ? 2.5f : 1f;

			if(Input.GetKeyDown(commonSettings.lowBeamHeadlightsKB)){
				lowBeamHeadLightsOn = !lowBeamHeadLightsOn;
			}

			if(Input.GetKeyDown(commonSettings.highBeamHeadlightsKB)){
				highBeamHeadLightsOn = true;
			}else if(Input.GetKeyUp(commonSettings.highBeamHeadlightsKB)){
				highBeamHeadLightsOn = false;
			}

			if(Input.GetKeyDown(commonSettings.startEngineKB))
				KillOrStartEngine();

			if(Input.GetKeyDown(commonSettings.rightIndicatorKB)){
				if(indicatorsOn != IndicatorsOn.Right)
					indicatorsOn = IndicatorsOn.Right;
				else
					indicatorsOn = IndicatorsOn.Off;
			}

			if(Input.GetKeyDown(commonSettings.leftIndicatorKB)){
				if(indicatorsOn != IndicatorsOn.Left)
					indicatorsOn = IndicatorsOn.Left;
				else
					indicatorsOn = IndicatorsOn.Off;
			}

			if(Input.GetKeyDown(commonSettings.hazardIndicatorKB)){
				if(indicatorsOn != IndicatorsOn.All){
					indicatorsOn = IndicatorsOn.Off;
					indicatorsOn = IndicatorsOn.All;
				}else{
					indicatorsOn = IndicatorsOn.Off;
				}
			}

			if (Input.GetKeyDown (commonSettings.NGear))
				NGear = true;

			if (Input.GetKeyUp (commonSettings.NGear))
				NGear = false;

			if(!automaticGear){

				if (Input.GetKeyDown (commonSettings.shiftGearUp))
					GearShiftUp ();

				if(Input.GetKeyDown(commonSettings.shiftGearDown))
					GearShiftDown();	

			}

			if(permanentGas) gasInput = 1f;


	}

	void OtherVisuals(){

		//Driver SteeringWheel Transform.
		if (SteeringWheel) {

			if (orgSteeringWheelRot.eulerAngles == Vector3.zero)
				orgSteeringWheelRot = SteeringWheel.transform.localRotation;
			
			switch (steeringWheelRotateAround) {

			case SteeringWheelRotateAround.XAxis:
				SteeringWheel.transform.localRotation = orgSteeringWheelRot * Quaternion.AngleAxis(((FrontLeftWheelCollider.wheelCollider.steerAngle) * steeringWheelAngleMultiplier), Vector3.right);
				break;

			case SteeringWheelRotateAround.YAxis:
				SteeringWheel.transform.localRotation = orgSteeringWheelRot * Quaternion.AngleAxis(((FrontLeftWheelCollider.wheelCollider.steerAngle) * steeringWheelAngleMultiplier), Vector3.up);
				break;

			case SteeringWheelRotateAround.ZAxis:
				SteeringWheel.transform.localRotation = orgSteeringWheelRot * Quaternion.AngleAxis(((FrontLeftWheelCollider.wheelCollider.steerAngle) * steeringWheelAngleMultiplier), Vector3.forward);
				break;

			}

		}

	}
	#endregion

	#region Engine	
	public void KillOrStartEngine (){
		
		if(engineRunning)
			KillEngine ();
		else
			StartEngine();

	}
	
	public void StartEngine (){

		StartCoroutine (StartEngineDelayed());

	}

	public void StartEngine (bool instantStart){

		if (instantStart) {
			
			fuelInput = 1f;
			engineRunning = true;

		} else {

			StartCoroutine (StartEngineDelayed());

		}

	}

	public IEnumerator StartEngineDelayed (){

		engineRunning = false;
		engineStartSound = CreateAudioSource.NewAudioSource(gameObject, "Engine Start AudioSource", 5, 10, 1, engineStartClip, false, true, true);
		if(engineStartSound.isPlaying)
			engineStartSound.Play();
		yield return new WaitForSeconds(1f);
		engineRunning = true;
		fuelInput = 1f;
		yield return new WaitForSeconds(1f);

	}

	public void KillEngine (){

		fuelInput = 0f;
		engineRunning = false;

	}	
	
	void Engine (){
		
		//Speed.
		speed = rigid.velocity.magnitude * 3.6f;

		//Steer Limit.
		steerAngle = Mathf.Lerp(orgSteerAngle, highspeedsteerAngle, (speed / highspeedsteerAngleAtspeed));

		float wheelRPM = _wheelTypeChoise == WheelType.FWD ? (FrontLeftWheelCollider.wheelRPMToSpeed + FrontRightWheelCollider.wheelRPMToSpeed) : (RearLeftWheelCollider.wheelRPMToSpeed + RearRightWheelCollider.wheelRPMToSpeed);
		
		rawEngineRPM = Mathf.Clamp(Mathf.MoveTowards(rawEngineRPM, (maxEngineRPM * 1.1f) * 
			(Mathf.Clamp01(Mathf.Lerp(0f, 1f, (1f - clutchInput) * 
				(((wheelRPM * direction) / 2f) / maxSpeedForGear[currentGear])) + 
				(((_gasInput) * clutchInput) + idleInput)))
		                                             , engineInertia * 100f), 0f, maxEngineRPM * 1.1f);
		
		rawEngineRPM *= _fuelInput;
		engineRPM = Mathf.Lerp(engineRPM, rawEngineRPM, Mathf.Lerp(Time.fixedDeltaTime * 5f, Time.fixedDeltaTime * 50f, rawEngineRPM / maxEngineRPM));
		
		
			
			if(/*_brakeInput < .5f &&*/ speed < 5)
				canGoReverseNow = true;
			else if(_brakeInput > 0 && transform.InverseTransformDirection(rigid.velocity).z > 1f)
				canGoReverseNow = false;
			
		

	}
	#endregion

	#region Sounds
	// Creating all audiosources at start.
	void SoundsInitialize (){

		switch (audioType) {

		case AudioType.OneSource:

			engineSoundHigh = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound High AudioSource", 5, 50, 0, engineClipHigh, true, true, false);

			if (autoCreateEngineOffSounds) {

				engineSoundHighOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound High Off AudioSource", 5, 50, 0, engineClipHigh, true, true, false);

				CreateAudioSource.NewLowPassFilter (engineSoundHighOff, 3000f);

			} else {

				engineSoundHighOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound High Off AudioSource", 5, 50, 0, engineClipHighOff, true, true, false);

			}

			break;

		case AudioType.TwoSource:

			engineSoundHigh = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound High AudioSource", 5, 50, 0, engineClipHigh, true, true, false);
			engineSoundLow = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound Low AudioSource", 5, 25, 0, engineClipLow, true, true, false);

			if (autoCreateEngineOffSounds) {

				engineSoundHighOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound High Off AudioSource", 5, 50, 0, engineClipHigh, true, true, false);
				engineSoundLowOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound Low Off AudioSource", 5, 25, 0, engineClipLow, true, true, false);

				CreateAudioSource.NewLowPassFilter (engineSoundHighOff, 3000f);
				CreateAudioSource.NewLowPassFilter (engineSoundLowOff, 3000f);

			} else {

				engineSoundHighOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound High Off AudioSource", 5, 50, 0, engineClipHighOff, true, true, false);
				engineSoundLowOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound Low Off AudioSource", 5, 25, 0, engineClipLowOff, true, true, false);

			}

			break;

		case AudioType.ThreeSource:

			engineSoundHigh = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound High AudioSource", 5, 50, 0, engineClipHigh, true, true, false);
			engineSoundMed = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound Medium AudioSource", 5, 50, 0, engineClipMed, true, true, false);
			engineSoundLow = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound Low AudioSource", 5, 25, 0, engineClipLow, true, true, false);

			if (autoCreateEngineOffSounds) {

				engineSoundHighOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound High Off AudioSource", 5, 50, 0, engineClipHigh, true, true, false);
				engineSoundMedOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound Medium Off AudioSource", 5, 50, 0, engineClipMed, true, true, false);
				engineSoundLowOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound Low Off AudioSource", 5, 25, 0, engineClipLow, true, true, false);

				if(engineSoundHighOff)
					CreateAudioSource.NewLowPassFilter (engineSoundHighOff, 3000f);
				if(engineSoundMedOff)
					CreateAudioSource.NewLowPassFilter (engineSoundMedOff, 3000f);
				if(engineSoundLowOff)
					CreateAudioSource.NewLowPassFilter (engineSoundLowOff, 3000f);

			} else {

				engineSoundHighOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound High Off AudioSource", 5, 50, 0, engineClipHighOff, true, true, false);
				engineSoundMedOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound Medium Off AudioSource", 5, 50, 0, engineClipMedOff, true, true, false);
				engineSoundLowOff = CreateAudioSource.NewAudioSource (gameObject, "Engine Sound Low Off AudioSource", 5, 25, 0, engineClipLowOff, true, true, false);

			}

			break;

		}

		engineSoundIdle = CreateAudioSource.NewAudioSource(gameObject, "Engine Sound Idle AudioSource", 5, 25, 0, engineClipIdle, true, true, false);
		reversingSound = CreateAudioSource.NewAudioSource(gameObject, "Reverse Sound AudioSource", 1, 10, 0, reversingClip, true, false, false);
		windSound = CreateAudioSource.NewAudioSource(gameObject, "Wind Sound AudioSource", 1, 10, 0, windClip, true, true, false);
		brakeSound = CreateAudioSource.NewAudioSource(gameObject, "Brake Sound AudioSource", 1, 10, 0, brakeClip, true, true, false);

		if(useNOS)
			NOSSound = CreateAudioSource.NewAudioSource(gameObject, "NOS Sound AudioSource", 5, 10, 1f, NOSClip, true, false, false);
		if(useNOS || useTurbo)
			blowSound = CreateAudioSource.NewAudioSource(gameObject, "NOS Blow", 1, 10, 1, null, false, false, false);
		if(useTurbo){
			turboSound = CreateAudioSource.NewAudioSource(gameObject, "Turbo Sound AudioSource", .1f, .5f, 0, turboClip, true, true, false);
			CreateAudioSource.NewHighPassFilter(turboSound, 10000f, 10);
		}
		
	}

	void Sounds(){

		windSound.volume = Mathf.Lerp (0f, commonSettings.maxWindSoundVolume, speed / 300f);
		windSound.pitch = UnityEngine.Random.Range(.9f, 1f);
		
		if(direction == 1)
			brakeSound.volume = Mathf.Lerp (0f, commonSettings.maxBrakeSoundVolume, Mathf.Clamp01((FrontLeftWheelCollider.wheelCollider.brakeTorque + FrontRightWheelCollider.wheelCollider.brakeTorque) / (brakeTorque * 2f)) * Mathf.Lerp(0f, 1f, FrontLeftWheelCollider.wheelCollider.rpm / 50f));
		else
			brakeSound.volume = 0f;

	}

	public void EngineSounds(){

		float lowRPM = 0f;
		float medRPM = 0f;
		float highRPM = 0f;

		if(engineRPM < ((maxEngineRPM) / 2f))
			lowRPM = Mathf.Lerp(0f, 1f, engineRPM / ((maxEngineRPM) / 2f));
		else
			lowRPM = Mathf.Lerp(1f, .25f, engineRPM / maxEngineRPM);

		if(engineRPM < ((maxEngineRPM) / 2f))
			medRPM = Mathf.Lerp(-.5f, 1f, engineRPM / ((maxEngineRPM) / 2f));
		else
			medRPM = Mathf.Lerp(1f, .5f, engineRPM / maxEngineRPM);

		highRPM = Mathf.Lerp(-1f, 1f, engineRPM / maxEngineRPM);

		lowRPM = Mathf.Clamp01 (lowRPM) * maxEngineSoundVolume;
		medRPM = Mathf.Clamp01 (medRPM) * maxEngineSoundVolume;
		highRPM = Mathf.Clamp01 (highRPM) * maxEngineSoundVolume;

		float volumeLevel = Mathf.Clamp (_gasInput, 0f, 1f);
		float pitchLevel = Mathf.Lerp (engineSoundHigh.pitch, Mathf.Lerp (minEngineSoundPitch, maxEngineSoundPitch, engineRPM / 7000f), Time.fixedDeltaTime * 50f);

		switch (audioType) {

		case VehiclePhysics.AudioType.OneSource:

			engineSoundHigh.volume = volumeLevel * maxEngineSoundVolume;
			engineSoundHigh.pitch = pitchLevel;

			engineSoundHighOff.volume = (1f - volumeLevel) * maxEngineSoundVolume;
			engineSoundHighOff.pitch = pitchLevel;

			if(!engineSoundHigh.isPlaying)
				engineSoundHigh.Play();

			break;

		case VehiclePhysics.AudioType.TwoSource:
			
			engineSoundHigh.volume = highRPM * volumeLevel;
			engineSoundHigh.pitch = pitchLevel;
			engineSoundLow.volume = lowRPM * volumeLevel;
			engineSoundLow.pitch = pitchLevel;

			engineSoundHighOff.volume = highRPM * (1f - volumeLevel);
			engineSoundHighOff.pitch = pitchLevel;
			engineSoundLowOff.volume = lowRPM * (1f - volumeLevel);
			engineSoundLowOff.pitch = pitchLevel;

			if(!engineSoundLow.isPlaying)
				engineSoundLow.Play();
			if(!engineSoundHigh.isPlaying)
				engineSoundHigh.Play();

			break;

		case VehiclePhysics.AudioType.ThreeSource:

			engineSoundHigh.volume = highRPM * volumeLevel;
			engineSoundHigh.pitch = pitchLevel;
			engineSoundMed.volume = medRPM * volumeLevel;
			engineSoundMed.pitch = pitchLevel;
			engineSoundLow.volume = lowRPM * volumeLevel;
			engineSoundLow.pitch = pitchLevel;

			engineSoundHighOff.volume = highRPM * (1f - volumeLevel);
			engineSoundHighOff.pitch = pitchLevel;
			engineSoundMedOff.volume = medRPM * (1f - volumeLevel);
			engineSoundMedOff.pitch = pitchLevel;
			engineSoundLowOff.volume = lowRPM * (1f - volumeLevel);
			engineSoundLowOff.pitch = pitchLevel;

			if(!engineSoundLow.isPlaying)
				engineSoundLow.Play();
			if(!engineSoundMed.isPlaying)
				engineSoundMed.Play();
			if(!engineSoundHigh.isPlaying)
				engineSoundHigh.Play();
			
			break;

		}

		if(engineSoundIdle){

			engineSoundIdle.volume = Mathf.Lerp(engineRunning ? 1f : 0f, 0f, engineRPM / maxEngineRPM);
			engineSoundIdle.pitch = pitchLevel;

		}

	}
	#endregion

	#region Driving Assistances	

	void ESPCheck(float steering){

		WheelHit frontHit1;
		FrontLeftWheelCollider.wheelCollider.GetGroundHit(out frontHit1);

		WheelHit frontHit2;
		FrontRightWheelCollider.wheelCollider.GetGroundHit(out frontHit2);

		frontSlip = frontHit1.sidewaysSlip + frontHit2.sidewaysSlip;

		WheelHit rearHit1;
		RearLeftWheelCollider.wheelCollider.GetGroundHit(out rearHit1);

		WheelHit rearHit2;
		RearRightWheelCollider.wheelCollider.GetGroundHit(out rearHit2);

		rearSlip = rearHit1.sidewaysSlip + rearHit2.sidewaysSlip;

		if(Mathf.Abs(frontSlip) >= ESPThreshold)
			underSteering = true;
		else
			underSteering = false;

		if(Mathf.Abs(rearSlip) >= ESPThreshold)
			overSteering = true;
		else
			overSteering = false;

		if(overSteering || underSteering)
			ESPAct = true;
		else
			ESPAct = false;
			
	}
	void AntiRollBars (){

		#region Horizontal

		WheelHit FrontWheelHit;
		
		float travelFL = 1.0f;
		float travelFR = 1.0f;
		
		bool groundedFL= FrontLeftWheelCollider.wheelCollider.GetGroundHit(out FrontWheelHit);
		
		if (groundedFL)
			travelFL = (-FrontLeftWheelCollider.transform.InverseTransformPoint(FrontWheelHit.point).y - FrontLeftWheelCollider.wheelCollider.radius) / FrontLeftWheelCollider.wheelCollider.suspensionDistance;
		
		bool groundedFR= FrontRightWheelCollider.wheelCollider.GetGroundHit(out FrontWheelHit);
		
		if (groundedFR)
			travelFR = (-FrontRightWheelCollider.transform.InverseTransformPoint(FrontWheelHit.point).y - FrontRightWheelCollider.wheelCollider.radius) / FrontRightWheelCollider.wheelCollider.suspensionDistance;
		
		float antiRollForceFrontHorizontal= (travelFL - travelFR) * antiRollFrontHorizontal;
		
		if (groundedFL)
			rigid.AddForceAtPosition(FrontLeftWheelCollider.transform.up * -antiRollForceFrontHorizontal, FrontLeftWheelCollider.transform.position); 
		if (groundedFR)
			rigid.AddForceAtPosition(FrontRightWheelCollider.transform.up * antiRollForceFrontHorizontal, FrontRightWheelCollider.transform.position); 
		
		WheelHit RearWheelHit;

		float travelRL = 1.0f;
		float travelRR = 1.0f;
		
		bool groundedRL= RearLeftWheelCollider.wheelCollider.GetGroundHit(out RearWheelHit);
		
		if (groundedRL)
			travelRL = (-RearLeftWheelCollider.transform.InverseTransformPoint(RearWheelHit.point).y - RearLeftWheelCollider.wheelCollider.radius) / RearLeftWheelCollider.wheelCollider.suspensionDistance;
		
		bool groundedRR= RearRightWheelCollider.wheelCollider.GetGroundHit(out RearWheelHit);
		
		if (groundedRR)
			travelRR = (-RearRightWheelCollider.transform.InverseTransformPoint(RearWheelHit.point).y - RearRightWheelCollider.wheelCollider.radius) / RearRightWheelCollider.wheelCollider.suspensionDistance;
		
		float antiRollForceRearHorizontal= (travelRL - travelRR) * antiRollRearHorizontal;
		
		if (groundedRL)
			rigid.AddForceAtPosition(RearLeftWheelCollider.transform.up * -antiRollForceRearHorizontal, RearLeftWheelCollider.transform.position); 
		if (groundedRR)
			rigid.AddForceAtPosition(RearRightWheelCollider.transform.up * antiRollForceRearHorizontal, RearRightWheelCollider.transform.position);
		
		#endregion

		#region Vertical

		float antiRollForceFrontVertical= (travelFL - travelRL) * antiRollVertical;

		if (groundedFL)
			rigid.AddForceAtPosition(FrontLeftWheelCollider.transform.up * -antiRollForceFrontVertical, FrontLeftWheelCollider.transform.position); 
		if (groundedRL)
			rigid.AddForceAtPosition(RearLeftWheelCollider.transform.up * antiRollForceFrontVertical, RearLeftWheelCollider.transform.position); 

		float antiRollForceRearVertical= (travelFR - travelRR) * antiRollVertical;

		if (groundedFR)
			rigid.AddForceAtPosition(FrontRightWheelCollider.transform.up * -antiRollForceRearVertical, FrontRightWheelCollider.transform.position); 
		if (groundedRR)
			rigid.AddForceAtPosition(RearRightWheelCollider.transform.up * antiRollForceRearVertical, RearRightWheelCollider.transform.position); 

		#endregion

	}

	void SteerHelper(){

		if (!steeringDirection || !velocityDirection) {

			if (!steeringDirection) {

				GameObject steeringDirectionGO = new GameObject ("Steering Direction");
				steeringDirectionGO.transform.SetParent (transform, false);
				steeringDirection = steeringDirectionGO.transform;
				steeringDirectionGO.transform.localPosition = new Vector3 (1f, 2f, 0f);
				steeringDirectionGO.transform.localScale = new Vector3 (.1f, .1f, 3f);

			}

			if (!velocityDirection) {

				GameObject velocityDirectionGO = new GameObject ("Velocity Direction");
				velocityDirectionGO.transform.SetParent (transform, false);
				velocityDirection = velocityDirectionGO.transform;
				velocityDirectionGO.transform.localPosition = new Vector3 (-1f, 2f, 0f);
				velocityDirectionGO.transform.localScale = new Vector3 (.1f, .1f, 3f);

			}

			return;

		}

		for (int i = 0; i < allWheelColliders.Length; i++){

			WheelHit hit;
			allWheelColliders[i].wheelCollider.GetGroundHit(out hit);
			if (hit.normal == Vector3.zero)
				return;

		}

		Vector3 v = rigid.angularVelocity;
		velocityAngle = (v.y * Mathf.Clamp(transform.InverseTransformDirection(rigid.velocity).z, -1f, 1f)) * Mathf.Rad2Deg;
		velocityDirection.localRotation = Quaternion.Lerp(velocityDirection.localRotation, Quaternion.AngleAxis(Mathf.Clamp(velocityAngle / 3f, -45f, 45f), Vector3.up), Time.fixedDeltaTime * 20f);
		steeringDirection.localRotation = Quaternion.Euler (0f, FrontLeftWheelCollider.wheelCollider.steerAngle, 0f);

		int normalizer = 1;

		if (steeringDirection.localRotation.y > velocityDirection.localRotation.y)
			normalizer = 1;
		else
			normalizer = -1;

		float angle2 = Quaternion.Angle (velocityDirection.localRotation, steeringDirection.localRotation) * (normalizer);

		rigid.AddRelativeTorque (Vector3.up * ((angle2 * (Mathf.Clamp(transform.InverseTransformDirection(rigid.velocity).z, -10f, 10f) / 600f)) * steerHelperAngularVelStrength), ForceMode.VelocityChange);

		if (Mathf.Abs(oldRotation - transform.eulerAngles.y) < 10f){

			float turnadjust = (transform.eulerAngles.y - oldRotation) * (steerHelperLinearVelStrength / 2f);
			Quaternion velRotation = Quaternion.AngleAxis(turnadjust, Vector3.up);
			rigid.velocity = (velRotation * rigid.velocity);

		}

		oldRotation = transform.eulerAngles.y;

	}

	void TractionHelper(){

		Vector3 velocity = rigid.velocity;
		velocity -= transform.up * Vector3.Dot(velocity, transform.up);
		velocity.Normalize();

		angle = -Mathf.Asin(Vector3.Dot(Vector3.Cross(transform.forward, velocity), transform.up));

		angularVelo = rigid.angularVelocity.y;

		if (angle * FrontLeftWheelCollider.wheelCollider.steerAngle < 0) {
			FrontLeftWheelCollider.tractionHelpedSidewaysStiffness = (1f - Mathf.Clamp01 (tractionHelperStrength * Mathf.Abs (angularVelo)));
		} else {
			FrontLeftWheelCollider.tractionHelpedSidewaysStiffness = 1f;
		}

		if (angle * FrontRightWheelCollider.wheelCollider.steerAngle < 0) {
			FrontRightWheelCollider.tractionHelpedSidewaysStiffness = (1f - Mathf.Clamp01 (tractionHelperStrength * Mathf.Abs (angularVelo)));
		} else {
			FrontRightWheelCollider.tractionHelpedSidewaysStiffness = 1f;
		}

	}

	private void DriftVariables(){
		
		WheelHit hit;
		RearRightWheelCollider.wheelCollider.GetGroundHit(out hit);

		if(Mathf.Abs(hit.sidewaysSlip) > .25f)
			driftingNow = true;
		else
			driftingNow = false;
		
		if(speed > 10f)
			driftAngle = hit.sidewaysSlip * .75f;
		else
			driftAngle = 0f;
		
	}
	#endregion

	#region Transmission
	void Clutch(){

		if(engineRunning)
			idleInput = Mathf.Lerp(1f, 0f, engineRPM / minEngineRPM);
		else
			idleInput = 0f;

		if (currentGear == 0) {

			if (useClutchMarginAtFirstGear) {
				
				if (launched >= .25f)
					clutchInput = Mathf.Lerp (clutchInput, (Mathf.Lerp (1f, (Mathf.Lerp (clutchInertia, 0f, ((RearLeftWheelCollider.wheelRPMToSpeed + RearRightWheelCollider.wheelRPMToSpeed) / 2f) / targetSpeedForGear [0])), Mathf.Abs (_gasInput))), Time.fixedDeltaTime * 5f);
				else
					clutchInput = Mathf.Lerp (clutchInput, 1f / speed, Time.fixedDeltaTime * 5f);
				
			} else {
				
				clutchInput = Mathf.Lerp (clutchInput, (Mathf.Lerp (1f, (Mathf.Lerp (clutchInertia, 0f, ((RearLeftWheelCollider.wheelRPMToSpeed + RearRightWheelCollider.wheelRPMToSpeed) / 2f) / targetSpeedForGear [0])), Mathf.Abs (_gasInput))), Time.fixedDeltaTime * 5f);

			}
			
		} else {
			
			if (changingGear)
				clutchInput = Mathf.Lerp (clutchInput, 1, Time.fixedDeltaTime * 5f);
			else
				clutchInput = Mathf.Lerp (clutchInput, 0, Time.fixedDeltaTime * 5f);

		} 

		if(cutGas || handbrakeInput >= .1f)
			clutchInput = 1f;

		if (NGear)
			clutchInput = 1f;

		clutchInput = Mathf.Clamp01(clutchInput);

	}

	void GearBox (){

		
			
			if(brakeInput > .9f  && transform.InverseTransformDirection(rigid.velocity).z < 1f && canGoReverseNow && automaticGear && !semiAutomaticGear && !changingGear && direction != -1)
				StartCoroutine(ChangeGear(-1));
			else if(brakeInput < .1f && transform.InverseTransformDirection(rigid.velocity).z > -1f && direction == -1 && !changingGear && automaticGear && !semiAutomaticGear)
				StartCoroutine(ChangeGear(0));
			
		

		if(automaticGear){

			if(currentGear < totalGears - 1 && !changingGear){
				if(speed >= (targetSpeedForGear[currentGear] * .9f) && FrontLeftWheelCollider.wheelCollider.rpm > 0){
					if(!semiAutomaticGear)
						StartCoroutine(ChangeGear(currentGear + 1));
					else if(semiAutomaticGear && direction != -1)
						StartCoroutine(ChangeGear(currentGear + 1));
				}
			}
			
			if(currentGear > 0){

				if(!changingGear){

					if(speed < (targetSpeedForGear[currentGear - 1] * .7f) && direction != -1){
						StartCoroutine(ChangeGear(currentGear - 1));
					}

				}

			}
			
		}

		if(direction == -1){
			
			if(!reversingSound.isPlaying)
				reversingSound.Play();
			
			reversingSound.volume = Mathf.Lerp(0f, 1f, speed / targetSpeedForGear[0]);
			reversingSound.pitch = reversingSound.volume;

		}else{
			
			if(reversingSound.isPlaying)
				reversingSound.Stop();
			
			reversingSound.volume = 0f;
			reversingSound.pitch = 0f;

		}
		
	}
	
	public IEnumerator ChangeGear(int gear){

		changingGear = true;

		if(gearShiftingClips.Length > 0){
			
			gearShiftingSound = CreateAudioSource.NewAudioSource(gameObject, "Gear Shifting AudioSource", 0f, .5f, commonSettings.maxGearShiftingSoundVolume, gearShiftingClips[UnityEngine.Random.Range(0, gearShiftingClips.Length)], false, true, true);

			if(!gearShiftingSound.isPlaying)
				gearShiftingSound.Play();
			
		}
		
		yield return new WaitForSeconds(gearShiftingDelay);

		if(gear == -1){
			
			currentGear = 0;

			if(!NGear)
				direction = -1;
			else
				direction = 0;

		}else{
			
			currentGear = gear;

			if(!NGear)
				direction = 1;
			else
				direction = 0;

		}

		changingGear = false;

	}

	public void GearShiftUp(){

		if(currentGear < totalGears - 1 && !changingGear){

			if(direction != -1)
				StartCoroutine(ChangeGear(currentGear + 1));
			else
				StartCoroutine(ChangeGear(0));

		}

	}

	public void GearShiftDown(){

		if(currentGear >= 0)
			StartCoroutine(ChangeGear(currentGear - 1));	

	}
	#endregion

	#region Rev Limiter, Fuel, Engine Heat, NOS, Turbo, Reset Car
	private void RevLimiter(){

		if((useRevLimiter && engineRPM >= maxEngineRPM))
			cutGas = true;
		else if(engineRPM < (maxEngineRPM * .95f))
			cutGas = false;
		
	}

	private void NOS(){

		if(!useNOS)
			return;

		if(!NOSSound)
			NOSSound = CreateAudioSource.NewAudioSource(gameObject, "NOS Sound AudioSource", 5, 10, 1f, NOSClip, true, false, false);

		if(!blowSound)
			blowSound = CreateAudioSource.NewAudioSource(gameObject, "NOS Blow", 1, 10, 1, null, false, false, false);

		if(boostInput > 1.5f && _gasInput >= .8f && NoS > 5){
			
			NoS -= NoSConsumption * Time.fixedDeltaTime;
			NoSRegenerateTime = 0f;

			if(!NOSSound.isPlaying)
				NOSSound.Play();
			
		}else{
			
			if(NoS < 100 && NoSRegenerateTime > 3)
				NoS += (NoSConsumption / 1.5f) * Time.fixedDeltaTime;
			
			NoSRegenerateTime += Time.fixedDeltaTime;

			if(NOSSound.isPlaying){
				
				NOSSound.Stop();
				blowSound.clip = commonSettings.blowoutClip[UnityEngine.Random.Range(0, commonSettings.blowoutClip.Length)];
				blowSound.Play();

			}

		}

	}

	private void Turbo(){

		if(!useTurbo)
			return;

		if (!turboSound) {
			
			turboSound = CreateAudioSource.NewAudioSource (gameObject, "Turbo Sound AudioSource", .1f, .5f, 0, turboClip, true, true, false);
			CreateAudioSource.NewHighPassFilter (turboSound, 10000f, 10);

		}

		turboBoost = Mathf.Lerp(turboBoost, Mathf.Clamp(Mathf.Pow(_gasInput, 10) * 30f + Mathf.Pow(engineRPM / maxEngineRPM, 10) * 30f, 0f, 30f), Time.fixedDeltaTime * 10f);

		if(turboBoost >= 25f){
			
			if(turboBoost < (turboSound.volume * 30f)){
				
				if(!blowSound.isPlaying){
					
					blowSound.clip = commonSettings.blowoutClip[UnityEngine.Random.Range(0, commonSettings.blowoutClip.Length)];
					blowSound.Play();

				}

			}

		}

		turboSound.volume = Mathf.Lerp(turboSound.volume, turboBoost / 30f, Time.fixedDeltaTime * 5f);
		turboSound.pitch = Mathf.Lerp(Mathf.Clamp(turboSound.pitch, 2f, 3f), (turboBoost / 30f) * 2f, Time.fixedDeltaTime * 5f);

	}

	private void Fuel(){

		fuelTank -= ((engineRPM / 10000f) * fuelConsumptionRate) * Time.fixedDeltaTime;
		fuelTank = Mathf.Clamp (fuelTank, 0f, fuelTankCapacity);

	}

	private void EngineHeat(){

		engineHeat += ((engineRPM / 10000f) * engineHeatRate) * Time.fixedDeltaTime;

		if (engineHeat > engineCoolingWaterThreshold)
			engineHeat -= engineCoolRate * Time.fixedDeltaTime;

		engineHeat -= (engineCoolRate / 10f) * Time.fixedDeltaTime;

		engineHeat = Mathf.Clamp (engineHeat, 15f, 120f);

	}
	
	private void ResetCar (){
		
		if(speed < 5 && !rigid.isKinematic){
			
			if(transform.eulerAngles.z < 300 && transform.eulerAngles.z > 60){
				resetTime += Time.deltaTime;
				if(resetTime > 3){
					transform.rotation = Quaternion.Euler (0f, transform.eulerAngles.y, 0f);
					transform.position = new Vector3(transform.position.x, transform.position.y + 3, transform.position.z);
					resetTime = 0f;
				}
			}
			
		}
		
	}
	#endregion

	#region Damage System

	// Collecting all meshes for damage.
	void DamageInit ()
	{
		if(contactSparkle){
			
			for(int i = 0; i < maximumContactSparkle; i++){
				GameObject sparks = (GameObject)Instantiate(contactSparkle, transform.position, Quaternion.identity) as GameObject;
				sparks.transform.SetParent(allContactParticles.transform);
				contactSparkeList.Add(sparks.GetComponent<ParticleSystem>());
				ParticleSystem.EmissionModule em = sparks.GetComponent<ParticleSystem>().emission;
				em.enabled = false;
			}
			
		}
    
        tempMeshes = new Mesh[deformMeshes.Length];
        damagedMeshes = new bool[deformMeshes.Length];
        meshVertices = new meshVerts[deformMeshes.Length];
        for (int i = 0; i < deformMeshes.Length; i++)
        {
            tempMeshes[i] = deformMeshes[i].mesh;
            meshVertices[i] = new meshVerts();
            meshVertices[i].verts = deformMeshes[i].mesh.vertices;
            meshVertices[i].initialVerts = deformMeshes[i].mesh.vertices;
            damagedMeshes[i] = false;
        }
	}

	// Enabling contact particles on collision.
	void CollisionParticles(Vector3 contactPoint){
		
		for(int i = 0; i < contactSparkeList.Count; i++){
			if(contactSparkeList[i].isPlaying)
				return;
			contactSparkeList[i].transform.position = contactPoint;
			ParticleSystem.EmissionModule em = contactSparkeList[i].emission;
			em.enabled = true;
			contactSparkeList[i].Play();
		}
		
	}
	void DamageApplication(Vector3 damagePoint, Vector3 damageForce, float damageForceLimit, Vector3 surfaceNormal, ContactPoint colPoint, bool useContactPoint, VehiclePhysics targetVehicle)
	{
		float colMag = Mathf.Min(damageForce.magnitude, maxCollisionMagnitude) * (1 - strength) * damageFactor;//Magnitude of collision
		float clampedColMag = Mathf.Pow(Mathf.Sqrt(colMag) * 0.5f, 1.5f);//Clamped magnitude of collision
		Vector3 clampedVel = Vector3.ClampMagnitude(damageForce, damageForceLimit);//Clamped velocity of collision
		Vector3 normalizedVel = damageForce.normalized;
		float surfaceDot;//Dot production of collision velocity and surface normal
		float massFactor = 1;//Multiplier for damage based on mass of other rigidbody
		//Transform curDamagePart;
		float damagePartFactor;
		MeshFilter curDamageMesh;
		Transform curDisplacePart;
		Transform seamKeeper = null;//Transform for maintaining seams on shattered parts
		Vector3 seamLocalPoint;
		Vector3 vertProjection;
		Vector3 translation;
		Vector3 clampedTranslation;
		Vector3 localPos;
		float vertDist;
		float distClamp;
		DetachablePart detachedPart;
		VehiclePhysicsWheelCollider wheelCol;

		//Get mass factor for multiplying damage
		if (useContactPoint)
		{
			damagePoint = colPoint.point;
			surfaceNormal = colPoint.normal;

			if (colPoint.otherCollider.attachedRigidbody)
			{
				massFactor = Mathf.Clamp01(colPoint.otherCollider.attachedRigidbody.mass / rigid.mass);
			}
		}

		surfaceDot = Mathf.Clamp01(Vector3.Dot(surfaceNormal, normalizedVel)) * (Vector3.Dot((transform.position - damagePoint).normalized, normalizedVel) + 1) * 0.5f;
        damagePartFactor = colMag * surfaceDot * massFactor * Mathf.Min(clampedColMag * 0.01f, (clampedColMag * 0.001f) / Mathf.Pow(Vector3.Distance(transform.position, damagePoint), clampedColMag));
        var healthLost = damagePartFactor * 2f;
        var scoreGained = (int) (speed/maxspeed * colMag * massFactor * clampedVel.magnitude);
        health = health < 0 ? 0 : health - healthLost;
		
		
		//Debug.Log("Health Lost : " + healthLost.ToString() + " Score Gained : " + scoreGained.ToString());

        
		if (Player.isServer)
        {
            Player.SetHealth(health);
            if (!ReferenceEquals(targetVehicle, null))
            {
                Player.SetScore(Player.score + scoreGained);
                Player.RpcDisplayPlayerHitEvent(targetVehicle.Player.playerName, healthLost, scoreGained);
            }
            else
            {
                Player.RpcDisplayObjectHitEvent("object", damageFactor * 5f);
            }
        }

		//Deform meshes
		for (int i = 0; i < deformMeshes.Length; i++)
		{
			curDamageMesh = deformMeshes[i];
			localPos = curDamageMesh.transform.InverseTransformPoint(damagePoint);
			translation = curDamageMesh.transform.InverseTransformDirection(clampedVel);
			clampedTranslation = Vector3.ClampMagnitude(translation, clampedColMag);

			//Shatter parts that can shatter
			ShatterPart shattered = curDamageMesh.GetComponent<ShatterPart>();
			if (shattered)
			{
				if(massFactor <= 0.001) return;

				seamKeeper = shattered.seamKeeper;
				if(!hasPivotIssues)
				{
					if (Vector3.Distance(curDamageMesh.transform.position, damagePoint) < colMag * surfaceDot * 0.1f * massFactor && colMag * surfaceDot * 1/massFactor > shattered.breakForce)
					{
						shattered.Shatter();
					}
				}
				else
				{
					if (Vector3.Distance(curDamageMesh.transform.parent.position, damagePoint) < colMag * surfaceDot * 0.1f * massFactor && colMag * surfaceDot * 1/massFactor > shattered.breakForce)
					{
						shattered.Shatter();
					}						
				}

			}

			//Actual deformation
			if (translation.sqrMagnitude > 0 && strength < 1)
			{
				for (int j = 0; j < meshVertices[i].verts.Length; j++)
				{
					vertDist = Vector3.Distance(meshVertices[i].verts[j], localPos);
					distClamp = (clampedColMag * 0.001f) / Mathf.Pow(vertDist, clampedColMag);

					if (distClamp > 0.001f)
					{
						damagedMeshes[i] = true;
						if (seamKeeper == null || seamlessDeform)
						{
							vertProjection = seamlessDeform ? Vector3.zero : Vector3.Project(normalizedVel, meshVertices[i].verts[j]);
							meshVertices[i].verts[j] += (clampedTranslation - vertProjection * (usePerlinNoise ? 1 + Mathf.PerlinNoise(meshVertices[i].verts[j].x * 100, meshVertices[i].verts[j].y * 100) : 1)) * surfaceDot * Mathf.Min(clampedColMag * 0.01f, distClamp) * massFactor;
						}
						else
						{
							seamLocalPoint = seamKeeper.InverseTransformPoint(curDamageMesh.transform.TransformPoint(meshVertices[i].verts[j]));
							meshVertices[i].verts[j] += (clampedTranslation - Vector3.Project(normalizedVel, seamLocalPoint) * (usePerlinNoise ? 1 + Mathf.PerlinNoise(seamLocalPoint.x * 100, seamLocalPoint.y * 100) : 1)) * surfaceDot * Mathf.Min(clampedColMag * 0.01f, distClamp) * massFactor;
						}
					}
				}
			}
		}

		seamKeeper = null;


		//Displace parts
		for (int i = 0; i < displaceParts.Length; i++)
		{
			curDisplacePart = displaceParts[i];
			translation = clampedVel;
			clampedTranslation = Vector3.ClampMagnitude(translation, clampedColMag);

			if (translation.sqrMagnitude > 0 && strength < 1)
			{
				vertDist = Vector3.Distance(curDisplacePart.position, damagePoint);
				distClamp = (clampedColMag * 0.001f) / Mathf.Pow(vertDist, clampedColMag);
				//Debug.Log((colMag * surfaceDot * massFactor).ToString());

				if (distClamp > 0.001f)
				{
					curDisplacePart.position += clampedTranslation * surfaceDot * Mathf.Min(clampedColMag * 0.01f, distClamp) * massFactor;

					//Detach detachable parts
					if (curDisplacePart.GetComponent<DetachablePart>())
					{
						detachedPart = curDisplacePart.GetComponent<DetachablePart>();

						if (!detachedPart.detached)
						{
							
							if (colMag * surfaceDot * massFactor > detachedPart.breakForce)
							{
								detachedPart.Detach();
							}
						}
						
					}
					
					wheelCol = curDisplacePart.GetComponent<VehiclePhysicsWheelCollider>();
					if (wheelCol)
					{
						

						if ((clampedColMag * surfaceDot * distClamp * 10 * massFactor > wheelCol.detachForce))
						{							
							wheelCol.Detach();
						}						
					}
				}
			}
		}
	}

	void FinalizeDamage()
	{
		//Apply vertices to actual meshes
		for (int i = 0; i < deformMeshes.Length; i++)
		{
			if (damagedMeshes[i])
			{
				tempMeshes[i].vertices = meshVertices[i].verts;

				if (calculateNormals)
				{
					tempMeshes[i].RecalculateNormals();
				}

				tempMeshes[i].RecalculateBounds();
			}

			damagedMeshes[i] = false;
		}
	}

	void Smoke()
	{
		if(smokeObj)
		{
			ParticleSystem.EmissionModule p = smokeObj.GetComponent<ParticleSystem>().emission;
			p.rateOverTime = new ParticleSystem.MinMaxCurve(health < 70 ? initialSmokeEmission * (1 - health/100) : 0);
		}
	}
	#endregion
	
	#region Gizmos
	void OnDrawGizmos(){
#if UNITY_EDITOR
		if(Application.isPlaying){

			WheelHit hit;

			for(int i = 0; i < allWheelColliders.Length; i++){

				allWheelColliders[i].wheelCollider.GetGroundHit(out hit);

				Matrix4x4 temp = Gizmos.matrix;
				Gizmos.matrix = Matrix4x4.TRS(allWheelColliders[i].transform.position, Quaternion.AngleAxis(-90, Vector3.right), Vector3.one);
				Gizmos.color = new Color((hit.force / rigid.mass) / 5f, (-hit.force / rigid.mass) / 5f, 0f);
				Gizmos.DrawFrustum(Vector3.zero, 2f, hit.force / rigid.mass, .1f, 1f);
				Gizmos.matrix = temp;

			}

		}
#endif
	}

	#endregion

	#region Generic Methods		
	public void TorqueCurves (){

		if(maxSpeedForGear == null)
			maxSpeedForGear = new float[totalGears];

		if(targetSpeedForGear == null)
			targetSpeedForGear = new float[totalGears - 1];

		if(maxSpeedForGear != null && maxSpeedForGear.Length != totalGears)
			maxSpeedForGear = new float[totalGears];

		if(targetSpeedForGear != null && targetSpeedForGear.Length != totalGears - 1)
			targetSpeedForGear = new float[totalGears - 1];

		for (int j = 0; j < totalGears; j++) 
			maxSpeedForGear [j] = Mathf.Lerp (0f, maxspeed * 1.1f, (float)(j + 1) / (float)(totalGears));

		if (autoGenerateTargetSpeedsForChangingGear) {
				
			for (int k = 0; k < totalGears - 1; k++) 
				targetSpeedForGear [k] = Mathf.Lerp (0, maxspeed * Mathf.Lerp(0f, 1f, gearShiftingThreshold), ((float)(k + 1) / (float)(totalGears)));

		}

		if (autoGenerateGearCurves) {

			if (orgMaxSpeed != maxspeed || orgGearShiftingThreshold != gearShiftingThreshold) {

				if (totalGears < 1) {
					
					Debug.LogError ("You are trying to set your vehicle gear to 0 or below! Why you trying to do this???");
					totalGears = 1;
					return;

				}

				engineTorqueCurve = new AnimationCurve[totalGears];

				currentGear = 0;

				for (int i = 0; i < engineTorqueCurve.Length; i++) 
					engineTorqueCurve [i] = new AnimationCurve (new Keyframe (0, 1));

				for (int i = 0; i < totalGears; i++) {

					if (i != 0) {
						
						engineTorqueCurve [i].MoveKey (0, new Keyframe (0, Mathf.Lerp (1f, .05f, (float)(i + 1) / (float)totalGears)));
						engineTorqueCurve [i].AddKey (Mathf.Lerp (0, maxspeed * .5f, ((float)(i) / (float)(totalGears))), Mathf.Lerp (1f, .5f, ((float)(i) / (float)(totalGears))));
						engineTorqueCurve [i].AddKey (Mathf.Lerp (0, maxspeed * 1f, ((float)(i + 1) / (float)(totalGears))), .15f);
						engineTorqueCurve [i].AddKey (Mathf.Lerp (0, maxspeed, ((float)(i + 1) / (float)(totalGears))) * 2f, -3f);
						engineTorqueCurve [i].postWrapMode = WrapMode.Clamp;

					} else {
						
						engineTorqueCurve [i].MoveKey (0, new Keyframe (0, 2f));
						engineTorqueCurve [i].AddKey (maxSpeedForGear [i] / 5f, 2.5f);
						engineTorqueCurve [i].AddKey (maxSpeedForGear [i], 0f);
						engineTorqueCurve [i].postWrapMode = WrapMode.Clamp;

					}

				orgMaxSpeed = maxspeed;
				orgGearShiftingThreshold = gearShiftingThreshold;

				}

			}

		}

	}

	public static void RemoveAt<T>(ref T[] arr, int index)
	{
		for (int a = index; a < arr.Length - 1; a++)
		{
			// moving elements downwards, to fill the gap at [index]
			arr[a] = arr[a + 1];
		}
		// finally, let's decrement Array's size by one
		Array.Resize(ref arr, arr.Length - 1);
	}

	void RemoveArrayNullElements()
	{
		MeshFilter[] a = deformMeshes;
        List<MeshFilter> aList = new List<MeshFilter>(a);
        aList.RemoveAll(x => x == null);
		deformMeshes = aList.ToArray();

		Transform[] t = displaceParts;
		List<Transform> tList = new List<Transform>(t);
		tList.RemoveAll(x => x == null);
		displaceParts = tList.ToArray();
	}

	// Method was used for creating new WheelColliders on Editor.
	public void CreateWheelColliders (){

		// Creating a list fot all wheel models.
		List <Transform> allWheelModels = new List<Transform>();
		allWheelModels.Add(FrontLeftWheelTransform); allWheelModels.Add(FrontRightWheelTransform); allWheelModels.Add(RearLeftWheelTransform); allWheelModels.Add(RearRightWheelTransform);

		// If we have additional rear wheels, add them too.
		if (ExtraRearWheelsTransform.Length > 0 && ExtraRearWheelsTransform [0]) {
			foreach (Transform t in ExtraRearWheelsTransform)
				allWheelModels.Add (t);
		}

		// If we don't have any wheelmodels, throw an error.
		if(allWheelModels != null && allWheelModels[0] == null){
			Debug.LogError("You haven't choose your Wheel Models. Please select all of your Wheel Models before creating Wheel Colliders. Script needs to know their sizes and positions, aye?");
			return;
		}

		// Holding default rotation.
		Quaternion currentRotation = transform.rotation;

		// Resetting rotation.
		transform.rotation = Quaternion.identity;

		// Creating a new gameobject called Wheel Colliders for all Wheel Colliders, and parenting it to this gameobject.
		GameObject WheelColliders = new GameObject("Wheel Colliders");
		WheelColliders.transform.SetParent(transform, false);
		WheelColliders.transform.localRotation = Quaternion.identity;
		WheelColliders.transform.localPosition = Vector3.zero;
		WheelColliders.transform.localScale = Vector3.one;

		// Creating WheelColliders.
		foreach(Transform wheel in allWheelModels){
			
			GameObject wheelcollider = new GameObject(wheel.transform.name); 
			
			wheelcollider.transform.position = wheel.transform.position;
			wheelcollider.transform.rotation = transform.rotation;
			wheelcollider.transform.name = wheel.transform.name;
			wheelcollider.transform.SetParent(WheelColliders.transform);
			wheelcollider.transform.localScale = Vector3.one;
			wheelcollider.AddComponent<WheelCollider>();

			Bounds biggestBound = new Bounds();
			Renderer[] renderers = wheel.GetComponentsInChildren<Renderer>();

			foreach (Renderer render in renderers) {
				if (render != GetComponent<Renderer>()){
					if(render.bounds.size.z > biggestBound.size.z)
						biggestBound = render.bounds;
				}
			}

			wheelcollider.GetComponent<WheelCollider>().radius = (biggestBound.extents.y) / transform.localScale.y;
			wheelcollider.AddComponent<VehiclePhysicsWheelCollider>();
			JointSpring spring = wheelcollider.GetComponent<WheelCollider>().suspensionSpring;

			spring.spring = 40000f;
			spring.damper = 1500f;
			spring.targetPosition = .5f;

			wheelcollider.GetComponent<WheelCollider>().suspensionSpring = spring;
			wheelcollider.GetComponent<WheelCollider>().suspensionDistance = .2f;
			wheelcollider.GetComponent<WheelCollider>().forceAppPointDistance = 0f;
			wheelcollider.GetComponent<WheelCollider>().mass = 40f;
			wheelcollider.GetComponent<WheelCollider>().wheelDampingRate = 1f;

			WheelFrictionCurve sidewaysFriction;
			WheelFrictionCurve forwardFriction;
			
			sidewaysFriction = wheelcollider.GetComponent<WheelCollider>().sidewaysFriction;
			forwardFriction = wheelcollider.GetComponent<WheelCollider>().forwardFriction;

			forwardFriction.extremumSlip = .3f;
			forwardFriction.extremumValue = 1;
			forwardFriction.asymptoteSlip = .8f;
			forwardFriction.asymptoteValue = .6f;
			forwardFriction.stiffness = 1.5f;

			sidewaysFriction.extremumSlip = .3f;
			sidewaysFriction.extremumValue = 1;
			sidewaysFriction.asymptoteSlip = .5f;
			sidewaysFriction.asymptoteValue = .8f;
			sidewaysFriction.stiffness = 1.5f;

			wheelcollider.GetComponent<WheelCollider>().sidewaysFriction = sidewaysFriction;
			wheelcollider.GetComponent<WheelCollider>().forwardFriction = forwardFriction;

		}
		
		VehiclePhysicsWheelCollider[] allWheelColliders = new VehiclePhysicsWheelCollider[allWheelModels.Count];
		allWheelColliders = GetComponentsInChildren<VehiclePhysicsWheelCollider>();
		
		FrontLeftWheelCollider = allWheelColliders[0];
		FrontRightWheelCollider = allWheelColliders[1];
		RearLeftWheelCollider = allWheelColliders[2];
		RearRightWheelCollider = allWheelColliders[3];

		ExtraRearWheelsCollider = new VehiclePhysicsWheelCollider[ExtraRearWheelsTransform.Length];

		for (int i = 0; i < ExtraRearWheelsTransform.Length; i++) {
			ExtraRearWheelsCollider [i] = allWheelColliders [i + 4];
		}

		transform.rotation = currentRotation;
		
	}
	#endregion

    #region Preview
	public void PreviewSmokeParticle(bool state){

		canControl = state;
		permanentGas = state;
		rigid.isKinematic = state;

	}
	#endregion

} 
